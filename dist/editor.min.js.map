{"version":3,"sources":["editor.js"],"names":["global","factory","exports","module","define","amd","self","editor","this","Editor","prototype","init","entry","console","log","Sizzle","window","i","support","Expr","getText","isXML","tokenize","compile","select","outermostContext","sortInput","hasDuplicate","setDocument","document","docElem","documentIsHTML","rbuggyQSA","rbuggyMatches","matches","contains","expando","Date","preferredDoc","dirruns","done","classCache","createCache","tokenCache","compilerCache","nonnativeSelectorCache","sortOrder","a","b","hasOwn","hasOwnProperty","arr","pop","push_native","push","slice","indexOf","list","elem","len","length","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rtrim","rcomma","rcombinators","rdescend","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rhtml","rinputs","rheader","rnative","rquickExpr","rsibling","runescape","funescape","_","escaped","escapedWhitespace","high","String","fromCharCode","rcssescape","fcssescape","ch","asCodePoint","charCodeAt","toString","unloadHandler","inDisabledFieldset","addCombinator","disabled","nodeName","toLowerCase","dir","next","apply","call","childNodes","nodeType","e","target","els","j","selector","context","results","seed","m","nid","match","groups","newSelector","newContext","ownerDocument","exec","getElementById","id","getElementsByTagName","getElementsByClassName","qsa","test","getAttribute","replace","setAttribute","toSelector","join","testContext","parentNode","querySelectorAll","qsaError","removeAttribute","keys","cache","key","value","cacheLength","shift","markFunction","fn","assert","el","createElement","removeChild","addHandle","attrs","handler","split","attrHandle","siblingCheck","cur","diff","sourceIndex","nextSibling","createInputPseudo","type","createButtonPseudo","name","createDisabledPseudo","isDisabled","createPositionalPseudo","argument","matchIndexes","namespace","namespaceURI","documentElement","node","hasCompare","subWindow","doc","defaultView","top","addEventListener","attachEvent","className","appendChild","createComment","getById","getElementsByName","filter","attrId","find","getAttributeNode","elems","tag","tmp","innerHTML","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","unshift","expr","elements","ret","attr","val","undefined","specified","escape","sel","error","msg","Error","uniqueSort","duplicates","detectDuplicates","sortStable","sort","splice","textContent","firstChild","nodeValue","selectors","createPseudo","relative",">","first"," ","+","~","preFilter","excess","unquoted","nodeNameSelector","pattern","operator","check","result","what","last","simple","forward","ofType","xml","uniqueCache","outerCache","nodeIndex","start","parent","useCache","lastChild","uniqueID","pseudo","args","setFilters","idx","matched","not","matcher","unmatched","has","text","lang","elemLang","hash","location","root","focus","activeElement","hasFocus","href","tabIndex","enabled","checked","selected","selectedIndex","empty","header","button","eq","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","tokens","combinator","base","skip","checkNonElements","doneName","oldCache","newCache","elementMatcher","matchers","condense","map","newUnmatched","mapped","setMatcher","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","contexts","multipleContexts","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","implicitRelative","matchContext","matchAnyContext","concat","filters","parseOnly","soFar","preFilters","cached","setMatchers","elementMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","Math","random","matcherFromGroupMatchers","token","compiled","defaultValue","_sizzle","noConflict","Object","assign","TypeError","item","Element","s"],"mappings":"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","file":"editor.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = global || self, global.editor = factory());\n}(this, function () { 'use strict';\n\n    var Editor = /** @class */ (function () {\n        function Editor() {\n        }\n        Editor.prototype.init = function (entry) {\n            console.log(Sizzle('#text'));\n        };\n        return Editor;\n    }());\n\n    /*!\n     * Sizzle CSS Selector Engine v2.3.4\n     * https://sizzlejs.com/\n     *\n     * Copyright JS Foundation and other contributors\n     * Released under the MIT license\n     * https://js.foundation/\n     *\n     * Date: 2019-04-08\n     */\n    (function( window ) {\n\n    var i,\n    \tsupport,\n    \tExpr,\n    \tgetText,\n    \tisXML,\n    \ttokenize,\n    \tcompile,\n    \tselect,\n    \toutermostContext,\n    \tsortInput,\n    \thasDuplicate,\n\n    \t// Local document vars\n    \tsetDocument,\n    \tdocument,\n    \tdocElem,\n    \tdocumentIsHTML,\n    \trbuggyQSA,\n    \trbuggyMatches,\n    \tmatches,\n    \tcontains,\n\n    \t// Instance-specific data\n    \texpando = \"sizzle\" + 1 * new Date(),\n    \tpreferredDoc = window.document,\n    \tdirruns = 0,\n    \tdone = 0,\n    \tclassCache = createCache(),\n    \ttokenCache = createCache(),\n    \tcompilerCache = createCache(),\n    \tnonnativeSelectorCache = createCache(),\n    \tsortOrder = function( a, b ) {\n    \t\tif ( a === b ) {\n    \t\t\thasDuplicate = true;\n    \t\t}\n    \t\treturn 0;\n    \t},\n\n    \t// Instance methods\n    \thasOwn = ({}).hasOwnProperty,\n    \tarr = [],\n    \tpop = arr.pop,\n    \tpush_native = arr.push,\n    \tpush = arr.push,\n    \tslice = arr.slice,\n    \t// Use a stripped-down indexOf as it's faster than native\n    \t// https://jsperf.com/thor-indexof-vs-for/5\n    \tindexOf = function( list, elem ) {\n    \t\tvar i = 0,\n    \t\t\tlen = list.length;\n    \t\tfor ( ; i < len; i++ ) {\n    \t\t\tif ( list[i] === elem ) {\n    \t\t\t\treturn i;\n    \t\t\t}\n    \t\t}\n    \t\treturn -1;\n    \t},\n\n    \tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n    \t// Regular expressions\n\n    \t// http://www.w3.org/TR/css3-selectors/#whitespace\n    \twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n    \t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    \tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n    \t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    \tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n    \t\t// Operator (capture 2)\n    \t\t\"*([*^$|!~]?=)\" + whitespace +\n    \t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n    \t\t\"*\\\\]\",\n\n    \tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n    \t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    \t\t// 1. quoted (capture 3; capture 4 or capture 5)\n    \t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n    \t\t// 2. simple (capture 6)\n    \t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n    \t\t// 3. anything else (capture 2)\n    \t\t\".*\" +\n    \t\t\")\\\\)|)\",\n\n    \t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    \trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n    \trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n    \trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n    \trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n    \trdescend = new RegExp( whitespace + \"|>\" ),\n\n    \trpseudo = new RegExp( pseudos ),\n    \tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n    \tmatchExpr = {\n    \t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n    \t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n    \t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n    \t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n    \t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n    \t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n    \t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n    \t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n    \t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n    \t\t// For use in libraries implementing .is()\n    \t\t// We use this for POS matching in `select`\n    \t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n    \t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n    \t},\n\n    \trhtml = /HTML$/i,\n    \trinputs = /^(?:input|select|textarea|button)$/i,\n    \trheader = /^h\\d$/i,\n\n    \trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n    \t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n    \trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n    \trsibling = /[+~]/,\n\n    \t// CSS escapes\n    \t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    \trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n    \tfunescape = function( _, escaped, escapedWhitespace ) {\n    \t\tvar high = \"0x\" + escaped - 0x10000;\n    \t\t// NaN means non-codepoint\n    \t\t// Support: Firefox<24\n    \t\t// Workaround erroneous numeric interpretation of +\"0x\"\n    \t\treturn high !== high || escapedWhitespace ?\n    \t\t\tescaped :\n    \t\t\thigh < 0 ?\n    \t\t\t\t// BMP codepoint\n    \t\t\t\tString.fromCharCode( high + 0x10000 ) :\n    \t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n    \t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n    \t},\n\n    \t// CSS string/identifier serialization\n    \t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n    \trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n    \tfcssescape = function( ch, asCodePoint ) {\n    \t\tif ( asCodePoint ) {\n\n    \t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n    \t\t\tif ( ch === \"\\0\" ) {\n    \t\t\t\treturn \"\\uFFFD\";\n    \t\t\t}\n\n    \t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n    \t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n    \t\t}\n\n    \t\t// Other potentially-special ASCII characters get backslash-escaped\n    \t\treturn \"\\\\\" + ch;\n    \t},\n\n    \t// Used for iframes\n    \t// See setDocument()\n    \t// Removing the function wrapper causes a \"Permission Denied\"\n    \t// error in IE\n    \tunloadHandler = function() {\n    \t\tsetDocument();\n    \t},\n\n    \tinDisabledFieldset = addCombinator(\n    \t\tfunction( elem ) {\n    \t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    \t\t},\n    \t\t{ dir: \"parentNode\", next: \"legend\" }\n    \t);\n\n    // Optimize for push.apply( _, NodeList )\n    try {\n    \tpush.apply(\n    \t\t(arr = slice.call( preferredDoc.childNodes )),\n    \t\tpreferredDoc.childNodes\n    \t);\n    \t// Support: Android<4.0\n    \t// Detect silently failing push.apply\n    \tarr[ preferredDoc.childNodes.length ].nodeType;\n    } catch ( e ) {\n    \tpush = { apply: arr.length ?\n\n    \t\t// Leverage slice if possible\n    \t\tfunction( target, els ) {\n    \t\t\tpush_native.apply( target, slice.call(els) );\n    \t\t} :\n\n    \t\t// Support: IE<9\n    \t\t// Otherwise append directly\n    \t\tfunction( target, els ) {\n    \t\t\tvar j = target.length,\n    \t\t\t\ti = 0;\n    \t\t\t// Can't trust NodeList.length\n    \t\t\twhile ( (target[j++] = els[i++]) ) {}\n    \t\t\ttarget.length = j - 1;\n    \t\t}\n    \t};\n    }\n\n    function Sizzle( selector, context, results, seed ) {\n    \tvar m, i, elem, nid, match, groups, newSelector,\n    \t\tnewContext = context && context.ownerDocument,\n\n    \t\t// nodeType defaults to 9, since context defaults to document\n    \t\tnodeType = context ? context.nodeType : 9;\n\n    \tresults = results || [];\n\n    \t// Return early from calls with invalid selector or context\n    \tif ( typeof selector !== \"string\" || !selector ||\n    \t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n    \t\treturn results;\n    \t}\n\n    \t// Try to shortcut find operations (as opposed to filters) in HTML documents\n    \tif ( !seed ) {\n\n    \t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n    \t\t\tsetDocument( context );\n    \t\t}\n    \t\tcontext = context || document;\n\n    \t\tif ( documentIsHTML ) {\n\n    \t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n    \t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n    \t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n    \t\t\t\t// ID selector\n    \t\t\t\tif ( (m = match[1]) ) {\n\n    \t\t\t\t\t// Document context\n    \t\t\t\t\tif ( nodeType === 9 ) {\n    \t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n    \t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n    \t\t\t\t\t\t\t// TODO: identify versions\n    \t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n    \t\t\t\t\t\t\tif ( elem.id === m ) {\n    \t\t\t\t\t\t\t\tresults.push( elem );\n    \t\t\t\t\t\t\t\treturn results;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\treturn results;\n    \t\t\t\t\t\t}\n\n    \t\t\t\t\t// Element context\n    \t\t\t\t\t} else {\n\n    \t\t\t\t\t\t// Support: IE, Opera, Webkit\n    \t\t\t\t\t\t// TODO: identify versions\n    \t\t\t\t\t\t// getElementById can match elements by name instead of ID\n    \t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n    \t\t\t\t\t\t\tcontains( context, elem ) &&\n    \t\t\t\t\t\t\telem.id === m ) {\n\n    \t\t\t\t\t\t\tresults.push( elem );\n    \t\t\t\t\t\t\treturn results;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t// Type selector\n    \t\t\t\t} else if ( match[2] ) {\n    \t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n    \t\t\t\t\treturn results;\n\n    \t\t\t\t// Class selector\n    \t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n    \t\t\t\t\tcontext.getElementsByClassName ) {\n\n    \t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n    \t\t\t\t\treturn results;\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t// Take advantage of querySelectorAll\n    \t\t\tif ( support.qsa &&\n    \t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n    \t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) &&\n\n    \t\t\t\t// Support: IE 8 only\n    \t\t\t\t// Exclude object elements\n    \t\t\t\t(nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\") ) {\n\n    \t\t\t\tnewSelector = selector;\n    \t\t\t\tnewContext = context;\n\n    \t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n    \t\t\t\t// descendant combinators, which is not what we want.\n    \t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n    \t\t\t\t// list with an ID selector referencing the scope context.\n    \t\t\t\t// Thanks to Andrew Dupont for this technique.\n    \t\t\t\tif ( nodeType === 1 && rdescend.test( selector ) ) {\n\n    \t\t\t\t\t// Capture the context ID, setting it first if necessary\n    \t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n    \t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// Prefix every selector in the list\n    \t\t\t\t\tgroups = tokenize( selector );\n    \t\t\t\t\ti = groups.length;\n    \t\t\t\t\twhile ( i-- ) {\n    \t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n    \t\t\t\t\t}\n    \t\t\t\t\tnewSelector = groups.join( \",\" );\n\n    \t\t\t\t\t// Expand context for sibling selectors\n    \t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n    \t\t\t\t\t\tcontext;\n    \t\t\t\t}\n\n    \t\t\t\ttry {\n    \t\t\t\t\tpush.apply( results,\n    \t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n    \t\t\t\t\t);\n    \t\t\t\t\treturn results;\n    \t\t\t\t} catch ( qsaError ) {\n    \t\t\t\t\tnonnativeSelectorCache( selector, true );\n    \t\t\t\t} finally {\n    \t\t\t\t\tif ( nid === expando ) {\n    \t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \t// All others\n    \treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n    }\n\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n    function createCache() {\n    \tvar keys = [];\n\n    \tfunction cache( key, value ) {\n    \t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n    \t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n    \t\t\t// Only keep the most recent entries\n    \t\t\tdelete cache[ keys.shift() ];\n    \t\t}\n    \t\treturn (cache[ key + \" \" ] = value);\n    \t}\n    \treturn cache;\n    }\n\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n    function markFunction( fn ) {\n    \tfn[ expando ] = true;\n    \treturn fn;\n    }\n\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n    function assert( fn ) {\n    \tvar el = document.createElement(\"fieldset\");\n\n    \ttry {\n    \t\treturn !!fn( el );\n    \t} catch (e) {\n    \t\treturn false;\n    \t} finally {\n    \t\t// Remove from its parent by default\n    \t\tif ( el.parentNode ) {\n    \t\t\tel.parentNode.removeChild( el );\n    \t\t}\n    \t\t// release memory in IE\n    \t\tel = null;\n    \t}\n    }\n\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n    function addHandle( attrs, handler ) {\n    \tvar arr = attrs.split(\"|\"),\n    \t\ti = arr.length;\n\n    \twhile ( i-- ) {\n    \t\tExpr.attrHandle[ arr[i] ] = handler;\n    \t}\n    }\n\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n    function siblingCheck( a, b ) {\n    \tvar cur = b && a,\n    \t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n    \t\t\ta.sourceIndex - b.sourceIndex;\n\n    \t// Use IE sourceIndex if available on both nodes\n    \tif ( diff ) {\n    \t\treturn diff;\n    \t}\n\n    \t// Check if b follows a\n    \tif ( cur ) {\n    \t\twhile ( (cur = cur.nextSibling) ) {\n    \t\t\tif ( cur === b ) {\n    \t\t\t\treturn -1;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \treturn a ? 1 : -1;\n    }\n\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n    function createInputPseudo( type ) {\n    \treturn function( elem ) {\n    \t\tvar name = elem.nodeName.toLowerCase();\n    \t\treturn name === \"input\" && elem.type === type;\n    \t};\n    }\n\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n    function createButtonPseudo( type ) {\n    \treturn function( elem ) {\n    \t\tvar name = elem.nodeName.toLowerCase();\n    \t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n    \t};\n    }\n\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n    function createDisabledPseudo( disabled ) {\n\n    \t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n    \treturn function( elem ) {\n\n    \t\t// Only certain elements can match :enabled or :disabled\n    \t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n    \t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n    \t\tif ( \"form\" in elem ) {\n\n    \t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n    \t\t\t// * listed form-associated elements in a disabled fieldset\n    \t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n    \t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n    \t\t\t// * option elements in a disabled optgroup\n    \t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n    \t\t\t// All such elements have a \"form\" property.\n    \t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n    \t\t\t\t// Option elements defer to a parent optgroup if present\n    \t\t\t\tif ( \"label\" in elem ) {\n    \t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n    \t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\treturn elem.disabled === disabled;\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\t// Support: IE 6 - 11\n    \t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n    \t\t\t\treturn elem.isDisabled === disabled ||\n\n    \t\t\t\t\t// Where there is no isDisabled, check manually\n    \t\t\t\t\t/* jshint -W018 */\n    \t\t\t\t\telem.isDisabled !== !disabled &&\n    \t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n    \t\t\t}\n\n    \t\t\treturn elem.disabled === disabled;\n\n    \t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n    \t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n    \t\t// even exist on them, let alone have a boolean value.\n    \t\t} else if ( \"label\" in elem ) {\n    \t\t\treturn elem.disabled === disabled;\n    \t\t}\n\n    \t\t// Remaining elements are neither :enabled nor :disabled\n    \t\treturn false;\n    \t};\n    }\n\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n    function createPositionalPseudo( fn ) {\n    \treturn markFunction(function( argument ) {\n    \t\targument = +argument;\n    \t\treturn markFunction(function( seed, matches ) {\n    \t\t\tvar j,\n    \t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n    \t\t\t\ti = matchIndexes.length;\n\n    \t\t\t// Match elements found at the specified indexes\n    \t\t\twhile ( i-- ) {\n    \t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n    \t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t});\n    \t});\n    }\n\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n    function testContext( context ) {\n    \treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    }\n\n    // Expose support vars for convenience\n    support = Sizzle.support = {};\n\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n    isXML = Sizzle.isXML = function( elem ) {\n    \tvar namespace = elem.namespaceURI,\n    \t\tdocElem = (elem.ownerDocument || elem).documentElement;\n\n    \t// Support: IE <=8\n    \t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n    \t// https://bugs.jquery.com/ticket/4833\n    \treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n    };\n\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n    setDocument = Sizzle.setDocument = function( node ) {\n    \tvar hasCompare, subWindow,\n    \t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n    \t// Return early if doc is invalid or already selected\n    \tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n    \t\treturn document;\n    \t}\n\n    \t// Update global variables\n    \tdocument = doc;\n    \tdocElem = document.documentElement;\n    \tdocumentIsHTML = !isXML( document );\n\n    \t// Support: IE 9-11, Edge\n    \t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n    \tif ( preferredDoc !== document &&\n    \t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n    \t\t// Support: IE 11, Edge\n    \t\tif ( subWindow.addEventListener ) {\n    \t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n    \t\t// Support: IE 9 - 10 only\n    \t\t} else if ( subWindow.attachEvent ) {\n    \t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n    \t\t}\n    \t}\n\n    \t/* Attributes\n    \t---------------------------------------------------------------------- */\n\n    \t// Support: IE<8\n    \t// Verify that getAttribute really returns attributes and not properties\n    \t// (excepting IE8 booleans)\n    \tsupport.attributes = assert(function( el ) {\n    \t\tel.className = \"i\";\n    \t\treturn !el.getAttribute(\"className\");\n    \t});\n\n    \t/* getElement(s)By*\n    \t---------------------------------------------------------------------- */\n\n    \t// Check if getElementsByTagName(\"*\") returns only elements\n    \tsupport.getElementsByTagName = assert(function( el ) {\n    \t\tel.appendChild( document.createComment(\"\") );\n    \t\treturn !el.getElementsByTagName(\"*\").length;\n    \t});\n\n    \t// Support: IE<9\n    \tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n    \t// Support: IE<10\n    \t// Check if getElementById returns elements by name\n    \t// The broken getElementById methods don't pick up programmatically-set names,\n    \t// so use a roundabout getElementsByName test\n    \tsupport.getById = assert(function( el ) {\n    \t\tdocElem.appendChild( el ).id = expando;\n    \t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n    \t});\n\n    \t// ID filter and find\n    \tif ( support.getById ) {\n    \t\tExpr.filter[\"ID\"] = function( id ) {\n    \t\t\tvar attrId = id.replace( runescape, funescape );\n    \t\t\treturn function( elem ) {\n    \t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n    \t\t\t};\n    \t\t};\n    \t\tExpr.find[\"ID\"] = function( id, context ) {\n    \t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n    \t\t\t\tvar elem = context.getElementById( id );\n    \t\t\t\treturn elem ? [ elem ] : [];\n    \t\t\t}\n    \t\t};\n    \t} else {\n    \t\tExpr.filter[\"ID\"] =  function( id ) {\n    \t\t\tvar attrId = id.replace( runescape, funescape );\n    \t\t\treturn function( elem ) {\n    \t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n    \t\t\t\t\telem.getAttributeNode(\"id\");\n    \t\t\t\treturn node && node.value === attrId;\n    \t\t\t};\n    \t\t};\n\n    \t\t// Support: IE 6 - 7 only\n    \t\t// getElementById is not reliable as a find shortcut\n    \t\tExpr.find[\"ID\"] = function( id, context ) {\n    \t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n    \t\t\t\tvar node, i, elems,\n    \t\t\t\t\telem = context.getElementById( id );\n\n    \t\t\t\tif ( elem ) {\n\n    \t\t\t\t\t// Verify the id attribute\n    \t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n    \t\t\t\t\tif ( node && node.value === id ) {\n    \t\t\t\t\t\treturn [ elem ];\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// Fall back on getElementsByName\n    \t\t\t\t\telems = context.getElementsByName( id );\n    \t\t\t\t\ti = 0;\n    \t\t\t\t\twhile ( (elem = elems[i++]) ) {\n    \t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n    \t\t\t\t\t\tif ( node && node.value === id ) {\n    \t\t\t\t\t\t\treturn [ elem ];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\treturn [];\n    \t\t\t}\n    \t\t};\n    \t}\n\n    \t// Tag\n    \tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n    \t\tfunction( tag, context ) {\n    \t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n    \t\t\t\treturn context.getElementsByTagName( tag );\n\n    \t\t\t// DocumentFragment nodes don't have gEBTN\n    \t\t\t} else if ( support.qsa ) {\n    \t\t\t\treturn context.querySelectorAll( tag );\n    \t\t\t}\n    \t\t} :\n\n    \t\tfunction( tag, context ) {\n    \t\t\tvar elem,\n    \t\t\t\ttmp = [],\n    \t\t\t\ti = 0,\n    \t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n    \t\t\t\tresults = context.getElementsByTagName( tag );\n\n    \t\t\t// Filter out possible comments\n    \t\t\tif ( tag === \"*\" ) {\n    \t\t\t\twhile ( (elem = results[i++]) ) {\n    \t\t\t\t\tif ( elem.nodeType === 1 ) {\n    \t\t\t\t\t\ttmp.push( elem );\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\treturn tmp;\n    \t\t\t}\n    \t\t\treturn results;\n    \t\t};\n\n    \t// Class\n    \tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n    \t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n    \t\t\treturn context.getElementsByClassName( className );\n    \t\t}\n    \t};\n\n    \t/* QSA/matchesSelector\n    \t---------------------------------------------------------------------- */\n\n    \t// QSA and matchesSelector support\n\n    \t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n    \trbuggyMatches = [];\n\n    \t// qSa(:focus) reports false when true (Chrome 21)\n    \t// We allow this because of a bug in IE8/9 that throws an error\n    \t// whenever `document.activeElement` is accessed on an iframe\n    \t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n    \t// See https://bugs.jquery.com/ticket/13378\n    \trbuggyQSA = [];\n\n    \tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n    \t\t// Build QSA regex\n    \t\t// Regex strategy adopted from Diego Perini\n    \t\tassert(function( el ) {\n    \t\t\t// Select is set to empty string on purpose\n    \t\t\t// This is to test IE's treatment of not explicitly\n    \t\t\t// setting a boolean content attribute,\n    \t\t\t// since its presence should be enough\n    \t\t\t// https://bugs.jquery.com/ticket/12359\n    \t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n    \t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n    \t\t\t\t\"<option selected=''></option></select>\";\n\n    \t\t\t// Support: IE8, Opera 11-12.16\n    \t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n    \t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n    \t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n    \t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n    \t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n    \t\t\t}\n\n    \t\t\t// Support: IE8\n    \t\t\t// Boolean attributes and \"value\" are not treated correctly\n    \t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n    \t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n    \t\t\t}\n\n    \t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n    \t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n    \t\t\t\trbuggyQSA.push(\"~=\");\n    \t\t\t}\n\n    \t\t\t// Webkit/Opera - :checked should return selected option elements\n    \t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n    \t\t\t// IE8 throws error here and will not see later tests\n    \t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n    \t\t\t\trbuggyQSA.push(\":checked\");\n    \t\t\t}\n\n    \t\t\t// Support: Safari 8+, iOS 8+\n    \t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n    \t\t\t// In-page `selector#id sibling-combinator selector` fails\n    \t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n    \t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n    \t\t\t}\n    \t\t});\n\n    \t\tassert(function( el ) {\n    \t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n    \t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n    \t\t\t// Support: Windows 8 Native Apps\n    \t\t\t// The type and name attributes are restricted during .innerHTML assignment\n    \t\t\tvar input = document.createElement(\"input\");\n    \t\t\tinput.setAttribute( \"type\", \"hidden\" );\n    \t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n    \t\t\t// Support: IE8\n    \t\t\t// Enforce case-sensitivity of name attribute\n    \t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n    \t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n    \t\t\t}\n\n    \t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n    \t\t\t// IE8 throws error here and will not see later tests\n    \t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n    \t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n    \t\t\t}\n\n    \t\t\t// Support: IE9-11+\n    \t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n    \t\t\tdocElem.appendChild( el ).disabled = true;\n    \t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n    \t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n    \t\t\t}\n\n    \t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n    \t\t\tel.querySelectorAll(\"*,:x\");\n    \t\t\trbuggyQSA.push(\",.*:\");\n    \t\t});\n    \t}\n\n    \tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n    \t\tdocElem.webkitMatchesSelector ||\n    \t\tdocElem.mozMatchesSelector ||\n    \t\tdocElem.oMatchesSelector ||\n    \t\tdocElem.msMatchesSelector) )) ) {\n\n    \t\tassert(function( el ) {\n    \t\t\t// Check to see if it's possible to do matchesSelector\n    \t\t\t// on a disconnected node (IE 9)\n    \t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n    \t\t\t// This should fail with an exception\n    \t\t\t// Gecko does not error, returns false instead\n    \t\t\tmatches.call( el, \"[s!='']:x\" );\n    \t\t\trbuggyMatches.push( \"!=\", pseudos );\n    \t\t});\n    \t}\n\n    \trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n    \trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n    \t/* Contains\n    \t---------------------------------------------------------------------- */\n    \thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n    \t// Element contains another\n    \t// Purposefully self-exclusive\n    \t// As in, an element does not contain itself\n    \tcontains = hasCompare || rnative.test( docElem.contains ) ?\n    \t\tfunction( a, b ) {\n    \t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n    \t\t\t\tbup = b && b.parentNode;\n    \t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n    \t\t\t\tadown.contains ?\n    \t\t\t\t\tadown.contains( bup ) :\n    \t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n    \t\t\t));\n    \t\t} :\n    \t\tfunction( a, b ) {\n    \t\t\tif ( b ) {\n    \t\t\t\twhile ( (b = b.parentNode) ) {\n    \t\t\t\t\tif ( b === a ) {\n    \t\t\t\t\t\treturn true;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t};\n\n    \t/* Sorting\n    \t---------------------------------------------------------------------- */\n\n    \t// Document order sorting\n    \tsortOrder = hasCompare ?\n    \tfunction( a, b ) {\n\n    \t\t// Flag for duplicate removal\n    \t\tif ( a === b ) {\n    \t\t\thasDuplicate = true;\n    \t\t\treturn 0;\n    \t\t}\n\n    \t\t// Sort on method existence if only one input has compareDocumentPosition\n    \t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n    \t\tif ( compare ) {\n    \t\t\treturn compare;\n    \t\t}\n\n    \t\t// Calculate position if both inputs belong to the same document\n    \t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n    \t\t\ta.compareDocumentPosition( b ) :\n\n    \t\t\t// Otherwise we know they are disconnected\n    \t\t\t1;\n\n    \t\t// Disconnected nodes\n    \t\tif ( compare & 1 ||\n    \t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n    \t\t\t// Choose the first element that is related to our preferred document\n    \t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n    \t\t\t\treturn -1;\n    \t\t\t}\n    \t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n    \t\t\t\treturn 1;\n    \t\t\t}\n\n    \t\t\t// Maintain original order\n    \t\t\treturn sortInput ?\n    \t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n    \t\t\t\t0;\n    \t\t}\n\n    \t\treturn compare & 4 ? -1 : 1;\n    \t} :\n    \tfunction( a, b ) {\n    \t\t// Exit early if the nodes are identical\n    \t\tif ( a === b ) {\n    \t\t\thasDuplicate = true;\n    \t\t\treturn 0;\n    \t\t}\n\n    \t\tvar cur,\n    \t\t\ti = 0,\n    \t\t\taup = a.parentNode,\n    \t\t\tbup = b.parentNode,\n    \t\t\tap = [ a ],\n    \t\t\tbp = [ b ];\n\n    \t\t// Parentless nodes are either documents or disconnected\n    \t\tif ( !aup || !bup ) {\n    \t\t\treturn a === document ? -1 :\n    \t\t\t\tb === document ? 1 :\n    \t\t\t\taup ? -1 :\n    \t\t\t\tbup ? 1 :\n    \t\t\t\tsortInput ?\n    \t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n    \t\t\t\t0;\n\n    \t\t// If the nodes are siblings, we can do a quick check\n    \t\t} else if ( aup === bup ) {\n    \t\t\treturn siblingCheck( a, b );\n    \t\t}\n\n    \t\t// Otherwise we need full lists of their ancestors for comparison\n    \t\tcur = a;\n    \t\twhile ( (cur = cur.parentNode) ) {\n    \t\t\tap.unshift( cur );\n    \t\t}\n    \t\tcur = b;\n    \t\twhile ( (cur = cur.parentNode) ) {\n    \t\t\tbp.unshift( cur );\n    \t\t}\n\n    \t\t// Walk down the tree looking for a discrepancy\n    \t\twhile ( ap[i] === bp[i] ) {\n    \t\t\ti++;\n    \t\t}\n\n    \t\treturn i ?\n    \t\t\t// Do a sibling check if the nodes have a common ancestor\n    \t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n    \t\t\t// Otherwise nodes in our document sort first\n    \t\t\tap[i] === preferredDoc ? -1 :\n    \t\t\tbp[i] === preferredDoc ? 1 :\n    \t\t\t0;\n    \t};\n\n    \treturn document;\n    };\n\n    Sizzle.matches = function( expr, elements ) {\n    \treturn Sizzle( expr, null, null, elements );\n    };\n\n    Sizzle.matchesSelector = function( elem, expr ) {\n    \t// Set document vars if needed\n    \tif ( ( elem.ownerDocument || elem ) !== document ) {\n    \t\tsetDocument( elem );\n    \t}\n\n    \tif ( support.matchesSelector && documentIsHTML &&\n    \t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n    \t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n    \t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n    \t\ttry {\n    \t\t\tvar ret = matches.call( elem, expr );\n\n    \t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n    \t\t\tif ( ret || support.disconnectedMatch ||\n    \t\t\t\t\t// As well, disconnected nodes are said to be in a document\n    \t\t\t\t\t// fragment in IE 9\n    \t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n    \t\t\t\treturn ret;\n    \t\t\t}\n    \t\t} catch (e) {\n    \t\t\tnonnativeSelectorCache( expr, true );\n    \t\t}\n    \t}\n\n    \treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n    };\n\n    Sizzle.contains = function( context, elem ) {\n    \t// Set document vars if needed\n    \tif ( ( context.ownerDocument || context ) !== document ) {\n    \t\tsetDocument( context );\n    \t}\n    \treturn contains( context, elem );\n    };\n\n    Sizzle.attr = function( elem, name ) {\n    \t// Set document vars if needed\n    \tif ( ( elem.ownerDocument || elem ) !== document ) {\n    \t\tsetDocument( elem );\n    \t}\n\n    \tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n    \t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n    \t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n    \t\t\tfn( elem, name, !documentIsHTML ) :\n    \t\t\tundefined;\n\n    \treturn val !== undefined ?\n    \t\tval :\n    \t\tsupport.attributes || !documentIsHTML ?\n    \t\t\telem.getAttribute( name ) :\n    \t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n    \t\t\t\tval.value :\n    \t\t\t\tnull;\n    };\n\n    Sizzle.escape = function( sel ) {\n    \treturn (sel + \"\").replace( rcssescape, fcssescape );\n    };\n\n    Sizzle.error = function( msg ) {\n    \tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n    };\n\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n    Sizzle.uniqueSort = function( results ) {\n    \tvar elem,\n    \t\tduplicates = [],\n    \t\tj = 0,\n    \t\ti = 0;\n\n    \t// Unless we *know* we can detect duplicates, assume their presence\n    \thasDuplicate = !support.detectDuplicates;\n    \tsortInput = !support.sortStable && results.slice( 0 );\n    \tresults.sort( sortOrder );\n\n    \tif ( hasDuplicate ) {\n    \t\twhile ( (elem = results[i++]) ) {\n    \t\t\tif ( elem === results[ i ] ) {\n    \t\t\t\tj = duplicates.push( i );\n    \t\t\t}\n    \t\t}\n    \t\twhile ( j-- ) {\n    \t\t\tresults.splice( duplicates[ j ], 1 );\n    \t\t}\n    \t}\n\n    \t// Clear input after sorting to release objects\n    \t// See https://github.com/jquery/sizzle/pull/225\n    \tsortInput = null;\n\n    \treturn results;\n    };\n\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n    getText = Sizzle.getText = function( elem ) {\n    \tvar node,\n    \t\tret = \"\",\n    \t\ti = 0,\n    \t\tnodeType = elem.nodeType;\n\n    \tif ( !nodeType ) {\n    \t\t// If no nodeType, this is expected to be an array\n    \t\twhile ( (node = elem[i++]) ) {\n    \t\t\t// Do not traverse comment nodes\n    \t\t\tret += getText( node );\n    \t\t}\n    \t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n    \t\t// Use textContent for elements\n    \t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n    \t\tif ( typeof elem.textContent === \"string\" ) {\n    \t\t\treturn elem.textContent;\n    \t\t} else {\n    \t\t\t// Traverse its children\n    \t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n    \t\t\t\tret += getText( elem );\n    \t\t\t}\n    \t\t}\n    \t} else if ( nodeType === 3 || nodeType === 4 ) {\n    \t\treturn elem.nodeValue;\n    \t}\n    \t// Do not include comment or processing instruction nodes\n\n    \treturn ret;\n    };\n\n    Expr = Sizzle.selectors = {\n\n    \t// Can be adjusted by the user\n    \tcacheLength: 50,\n\n    \tcreatePseudo: markFunction,\n\n    \tmatch: matchExpr,\n\n    \tattrHandle: {},\n\n    \tfind: {},\n\n    \trelative: {\n    \t\t\">\": { dir: \"parentNode\", first: true },\n    \t\t\" \": { dir: \"parentNode\" },\n    \t\t\"+\": { dir: \"previousSibling\", first: true },\n    \t\t\"~\": { dir: \"previousSibling\" }\n    \t},\n\n    \tpreFilter: {\n    \t\t\"ATTR\": function( match ) {\n    \t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n    \t\t\t// Move the given value to match[3] whether quoted or unquoted\n    \t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n    \t\t\tif ( match[2] === \"~=\" ) {\n    \t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n    \t\t\t}\n\n    \t\t\treturn match.slice( 0, 4 );\n    \t\t},\n\n    \t\t\"CHILD\": function( match ) {\n    \t\t\t/* matches from matchExpr[\"CHILD\"]\n    \t\t\t\t1 type (only|nth|...)\n    \t\t\t\t2 what (child|of-type)\n    \t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n    \t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n    \t\t\t\t5 sign of xn-component\n    \t\t\t\t6 x of xn-component\n    \t\t\t\t7 sign of y-component\n    \t\t\t\t8 y of y-component\n    \t\t\t*/\n    \t\t\tmatch[1] = match[1].toLowerCase();\n\n    \t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n    \t\t\t\t// nth-* requires argument\n    \t\t\t\tif ( !match[3] ) {\n    \t\t\t\t\tSizzle.error( match[0] );\n    \t\t\t\t}\n\n    \t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n    \t\t\t\t// remember that false/true cast respectively to 0/1\n    \t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n    \t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n    \t\t\t// other types prohibit arguments\n    \t\t\t} else if ( match[3] ) {\n    \t\t\t\tSizzle.error( match[0] );\n    \t\t\t}\n\n    \t\t\treturn match;\n    \t\t},\n\n    \t\t\"PSEUDO\": function( match ) {\n    \t\t\tvar excess,\n    \t\t\t\tunquoted = !match[6] && match[2];\n\n    \t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n    \t\t\t\treturn null;\n    \t\t\t}\n\n    \t\t\t// Accept quoted arguments as-is\n    \t\t\tif ( match[3] ) {\n    \t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n    \t\t\t// Strip excess characters from unquoted arguments\n    \t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n    \t\t\t\t// Get excess from tokenize (recursively)\n    \t\t\t\t(excess = tokenize( unquoted, true )) &&\n    \t\t\t\t// advance to the next closing parenthesis\n    \t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n    \t\t\t\t// excess is a negative index\n    \t\t\t\tmatch[0] = match[0].slice( 0, excess );\n    \t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n    \t\t\t}\n\n    \t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n    \t\t\treturn match.slice( 0, 3 );\n    \t\t}\n    \t},\n\n    \tfilter: {\n\n    \t\t\"TAG\": function( nodeNameSelector ) {\n    \t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n    \t\t\treturn nodeNameSelector === \"*\" ?\n    \t\t\t\tfunction() { return true; } :\n    \t\t\t\tfunction( elem ) {\n    \t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n    \t\t\t\t};\n    \t\t},\n\n    \t\t\"CLASS\": function( className ) {\n    \t\t\tvar pattern = classCache[ className + \" \" ];\n\n    \t\t\treturn pattern ||\n    \t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n    \t\t\t\tclassCache( className, function( elem ) {\n    \t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n    \t\t\t\t});\n    \t\t},\n\n    \t\t\"ATTR\": function( name, operator, check ) {\n    \t\t\treturn function( elem ) {\n    \t\t\t\tvar result = Sizzle.attr( elem, name );\n\n    \t\t\t\tif ( result == null ) {\n    \t\t\t\t\treturn operator === \"!=\";\n    \t\t\t\t}\n    \t\t\t\tif ( !operator ) {\n    \t\t\t\t\treturn true;\n    \t\t\t\t}\n\n    \t\t\t\tresult += \"\";\n\n    \t\t\t\treturn operator === \"=\" ? result === check :\n    \t\t\t\t\toperator === \"!=\" ? result !== check :\n    \t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n    \t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n    \t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n    \t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n    \t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n    \t\t\t\t\tfalse;\n    \t\t\t};\n    \t\t},\n\n    \t\t\"CHILD\": function( type, what, argument, first, last ) {\n    \t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n    \t\t\t\tforward = type.slice( -4 ) !== \"last\",\n    \t\t\t\tofType = what === \"of-type\";\n\n    \t\t\treturn first === 1 && last === 0 ?\n\n    \t\t\t\t// Shortcut for :nth-*(n)\n    \t\t\t\tfunction( elem ) {\n    \t\t\t\t\treturn !!elem.parentNode;\n    \t\t\t\t} :\n\n    \t\t\t\tfunction( elem, context, xml ) {\n    \t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n    \t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n    \t\t\t\t\t\tparent = elem.parentNode,\n    \t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n    \t\t\t\t\t\tuseCache = !xml && !ofType,\n    \t\t\t\t\t\tdiff = false;\n\n    \t\t\t\t\tif ( parent ) {\n\n    \t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n    \t\t\t\t\t\tif ( simple ) {\n    \t\t\t\t\t\t\twhile ( dir ) {\n    \t\t\t\t\t\t\t\tnode = elem;\n    \t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n    \t\t\t\t\t\t\t\t\tif ( ofType ?\n    \t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n    \t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n    \t\t\t\t\t\t\t\t\t\treturn false;\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n    \t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\treturn true;\n    \t\t\t\t\t\t}\n\n    \t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n    \t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n    \t\t\t\t\t\tif ( forward && useCache ) {\n\n    \t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n    \t\t\t\t\t\t\t// ...in a gzip-friendly way\n    \t\t\t\t\t\t\tnode = parent;\n    \t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n    \t\t\t\t\t\t\t// Support: IE <9 only\n    \t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n    \t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n    \t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n    \t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n    \t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n    \t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n    \t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n    \t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n    \t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n    \t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n    \t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n    \t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n    \t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n    \t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t// Use previously-cached element index if available\n    \t\t\t\t\t\t\tif ( useCache ) {\n    \t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n    \t\t\t\t\t\t\t\tnode = elem;\n    \t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n    \t\t\t\t\t\t\t\t// Support: IE <9 only\n    \t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n    \t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n    \t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n    \t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n    \t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n    \t\t\t\t\t\t\t\tdiff = nodeIndex;\n    \t\t\t\t\t\t\t}\n\n    \t\t\t\t\t\t\t// xml :nth-child(...)\n    \t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n    \t\t\t\t\t\t\tif ( diff === false ) {\n    \t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n    \t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n    \t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n    \t\t\t\t\t\t\t\t\tif ( ( ofType ?\n    \t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n    \t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n    \t\t\t\t\t\t\t\t\t\t++diff ) {\n\n    \t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n    \t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n    \t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n    \t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n    \t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n    \t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n    \t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n    \t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n    \t\t\t\t\t\t\t\t\t\t}\n\n    \t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n\n    \t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n    \t\t\t\t\t\tdiff -= last;\n    \t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n    \t\t\t\t\t}\n    \t\t\t\t};\n    \t\t},\n\n    \t\t\"PSEUDO\": function( pseudo, argument ) {\n    \t\t\t// pseudo-class names are case-insensitive\n    \t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n    \t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n    \t\t\t// Remember that setFilters inherits from pseudos\n    \t\t\tvar args,\n    \t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n    \t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n    \t\t\t// The user may use createPseudo to indicate that\n    \t\t\t// arguments are needed to create the filter function\n    \t\t\t// just as Sizzle does\n    \t\t\tif ( fn[ expando ] ) {\n    \t\t\t\treturn fn( argument );\n    \t\t\t}\n\n    \t\t\t// But maintain support for old signatures\n    \t\t\tif ( fn.length > 1 ) {\n    \t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n    \t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n    \t\t\t\t\tmarkFunction(function( seed, matches ) {\n    \t\t\t\t\t\tvar idx,\n    \t\t\t\t\t\t\tmatched = fn( seed, argument ),\n    \t\t\t\t\t\t\ti = matched.length;\n    \t\t\t\t\t\twhile ( i-- ) {\n    \t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n    \t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}) :\n    \t\t\t\t\tfunction( elem ) {\n    \t\t\t\t\t\treturn fn( elem, 0, args );\n    \t\t\t\t\t};\n    \t\t\t}\n\n    \t\t\treturn fn;\n    \t\t}\n    \t},\n\n    \tpseudos: {\n    \t\t// Potentially complex pseudos\n    \t\t\"not\": markFunction(function( selector ) {\n    \t\t\t// Trim the selector passed to compile\n    \t\t\t// to avoid treating leading and trailing\n    \t\t\t// spaces as combinators\n    \t\t\tvar input = [],\n    \t\t\t\tresults = [],\n    \t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n    \t\t\treturn matcher[ expando ] ?\n    \t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n    \t\t\t\t\tvar elem,\n    \t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n    \t\t\t\t\t\ti = seed.length;\n\n    \t\t\t\t\t// Match elements unmatched by `matcher`\n    \t\t\t\t\twhile ( i-- ) {\n    \t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n    \t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}) :\n    \t\t\t\tfunction( elem, context, xml ) {\n    \t\t\t\t\tinput[0] = elem;\n    \t\t\t\t\tmatcher( input, null, xml, results );\n    \t\t\t\t\t// Don't keep the element (issue #299)\n    \t\t\t\t\tinput[0] = null;\n    \t\t\t\t\treturn !results.pop();\n    \t\t\t\t};\n    \t\t}),\n\n    \t\t\"has\": markFunction(function( selector ) {\n    \t\t\treturn function( elem ) {\n    \t\t\t\treturn Sizzle( selector, elem ).length > 0;\n    \t\t\t};\n    \t\t}),\n\n    \t\t\"contains\": markFunction(function( text ) {\n    \t\t\ttext = text.replace( runescape, funescape );\n    \t\t\treturn function( elem ) {\n    \t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n    \t\t\t};\n    \t\t}),\n\n    \t\t// \"Whether an element is represented by a :lang() selector\n    \t\t// is based solely on the element's language value\n    \t\t// being equal to the identifier C,\n    \t\t// or beginning with the identifier C immediately followed by \"-\".\n    \t\t// The matching of C against the element's language value is performed case-insensitively.\n    \t\t// The identifier C does not have to be a valid language name.\"\n    \t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n    \t\t\"lang\": markFunction( function( lang ) {\n    \t\t\t// lang value must be a valid identifier\n    \t\t\tif ( !ridentifier.test(lang || \"\") ) {\n    \t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n    \t\t\t}\n    \t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n    \t\t\treturn function( elem ) {\n    \t\t\t\tvar elemLang;\n    \t\t\t\tdo {\n    \t\t\t\t\tif ( (elemLang = documentIsHTML ?\n    \t\t\t\t\t\telem.lang :\n    \t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n    \t\t\t\t\t\telemLang = elemLang.toLowerCase();\n    \t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n    \t\t\t\t\t}\n    \t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n    \t\t\t\treturn false;\n    \t\t\t};\n    \t\t}),\n\n    \t\t// Miscellaneous\n    \t\t\"target\": function( elem ) {\n    \t\t\tvar hash = window.location && window.location.hash;\n    \t\t\treturn hash && hash.slice( 1 ) === elem.id;\n    \t\t},\n\n    \t\t\"root\": function( elem ) {\n    \t\t\treturn elem === docElem;\n    \t\t},\n\n    \t\t\"focus\": function( elem ) {\n    \t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n    \t\t},\n\n    \t\t// Boolean properties\n    \t\t\"enabled\": createDisabledPseudo( false ),\n    \t\t\"disabled\": createDisabledPseudo( true ),\n\n    \t\t\"checked\": function( elem ) {\n    \t\t\t// In CSS3, :checked should return both checked and selected elements\n    \t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n    \t\t\tvar nodeName = elem.nodeName.toLowerCase();\n    \t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n    \t\t},\n\n    \t\t\"selected\": function( elem ) {\n    \t\t\t// Accessing this property makes selected-by-default\n    \t\t\t// options in Safari work properly\n    \t\t\tif ( elem.parentNode ) {\n    \t\t\t\telem.parentNode.selectedIndex;\n    \t\t\t}\n\n    \t\t\treturn elem.selected === true;\n    \t\t},\n\n    \t\t// Contents\n    \t\t\"empty\": function( elem ) {\n    \t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n    \t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n    \t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n    \t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n    \t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n    \t\t\t\tif ( elem.nodeType < 6 ) {\n    \t\t\t\t\treturn false;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn true;\n    \t\t},\n\n    \t\t\"parent\": function( elem ) {\n    \t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n    \t\t},\n\n    \t\t// Element/input types\n    \t\t\"header\": function( elem ) {\n    \t\t\treturn rheader.test( elem.nodeName );\n    \t\t},\n\n    \t\t\"input\": function( elem ) {\n    \t\t\treturn rinputs.test( elem.nodeName );\n    \t\t},\n\n    \t\t\"button\": function( elem ) {\n    \t\t\tvar name = elem.nodeName.toLowerCase();\n    \t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n    \t\t},\n\n    \t\t\"text\": function( elem ) {\n    \t\t\tvar attr;\n    \t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n    \t\t\t\telem.type === \"text\" &&\n\n    \t\t\t\t// Support: IE<8\n    \t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n    \t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n    \t\t},\n\n    \t\t// Position-in-collection\n    \t\t\"first\": createPositionalPseudo(function() {\n    \t\t\treturn [ 0 ];\n    \t\t}),\n\n    \t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n    \t\t\treturn [ length - 1 ];\n    \t\t}),\n\n    \t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n    \t\t\treturn [ argument < 0 ? argument + length : argument ];\n    \t\t}),\n\n    \t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n    \t\t\tvar i = 0;\n    \t\t\tfor ( ; i < length; i += 2 ) {\n    \t\t\t\tmatchIndexes.push( i );\n    \t\t\t}\n    \t\t\treturn matchIndexes;\n    \t\t}),\n\n    \t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n    \t\t\tvar i = 1;\n    \t\t\tfor ( ; i < length; i += 2 ) {\n    \t\t\t\tmatchIndexes.push( i );\n    \t\t\t}\n    \t\t\treturn matchIndexes;\n    \t\t}),\n\n    \t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n    \t\t\tvar i = argument < 0 ?\n    \t\t\t\targument + length :\n    \t\t\t\targument > length ?\n    \t\t\t\t\tlength :\n    \t\t\t\t\targument;\n    \t\t\tfor ( ; --i >= 0; ) {\n    \t\t\t\tmatchIndexes.push( i );\n    \t\t\t}\n    \t\t\treturn matchIndexes;\n    \t\t}),\n\n    \t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n    \t\t\tvar i = argument < 0 ? argument + length : argument;\n    \t\t\tfor ( ; ++i < length; ) {\n    \t\t\t\tmatchIndexes.push( i );\n    \t\t\t}\n    \t\t\treturn matchIndexes;\n    \t\t})\n    \t}\n    };\n\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n    // Add button/input type pseudos\n    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n    \tExpr.pseudos[ i ] = createInputPseudo( i );\n    }\n    for ( i in { submit: true, reset: true } ) {\n    \tExpr.pseudos[ i ] = createButtonPseudo( i );\n    }\n\n    // Easy API for creating new setFilters\n    function setFilters() {}\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n    \tvar matched, match, tokens, type,\n    \t\tsoFar, groups, preFilters,\n    \t\tcached = tokenCache[ selector + \" \" ];\n\n    \tif ( cached ) {\n    \t\treturn parseOnly ? 0 : cached.slice( 0 );\n    \t}\n\n    \tsoFar = selector;\n    \tgroups = [];\n    \tpreFilters = Expr.preFilter;\n\n    \twhile ( soFar ) {\n\n    \t\t// Comma and first run\n    \t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n    \t\t\tif ( match ) {\n    \t\t\t\t// Don't consume trailing commas as valid\n    \t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n    \t\t\t}\n    \t\t\tgroups.push( (tokens = []) );\n    \t\t}\n\n    \t\tmatched = false;\n\n    \t\t// Combinators\n    \t\tif ( (match = rcombinators.exec( soFar )) ) {\n    \t\t\tmatched = match.shift();\n    \t\t\ttokens.push({\n    \t\t\t\tvalue: matched,\n    \t\t\t\t// Cast descendant combinators to space\n    \t\t\t\ttype: match[0].replace( rtrim, \" \" )\n    \t\t\t});\n    \t\t\tsoFar = soFar.slice( matched.length );\n    \t\t}\n\n    \t\t// Filters\n    \t\tfor ( type in Expr.filter ) {\n    \t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n    \t\t\t\t(match = preFilters[ type ]( match ))) ) {\n    \t\t\t\tmatched = match.shift();\n    \t\t\t\ttokens.push({\n    \t\t\t\t\tvalue: matched,\n    \t\t\t\t\ttype: type,\n    \t\t\t\t\tmatches: match\n    \t\t\t\t});\n    \t\t\t\tsoFar = soFar.slice( matched.length );\n    \t\t\t}\n    \t\t}\n\n    \t\tif ( !matched ) {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n\n    \t// Return the length of the invalid excess\n    \t// if we're just parsing\n    \t// Otherwise, throw an error or return tokens\n    \treturn parseOnly ?\n    \t\tsoFar.length :\n    \t\tsoFar ?\n    \t\t\tSizzle.error( selector ) :\n    \t\t\t// Cache the tokens\n    \t\t\ttokenCache( selector, groups ).slice( 0 );\n    };\n\n    function toSelector( tokens ) {\n    \tvar i = 0,\n    \t\tlen = tokens.length,\n    \t\tselector = \"\";\n    \tfor ( ; i < len; i++ ) {\n    \t\tselector += tokens[i].value;\n    \t}\n    \treturn selector;\n    }\n\n    function addCombinator( matcher, combinator, base ) {\n    \tvar dir = combinator.dir,\n    \t\tskip = combinator.next,\n    \t\tkey = skip || dir,\n    \t\tcheckNonElements = base && key === \"parentNode\",\n    \t\tdoneName = done++;\n\n    \treturn combinator.first ?\n    \t\t// Check against closest ancestor/preceding element\n    \t\tfunction( elem, context, xml ) {\n    \t\t\twhile ( (elem = elem[ dir ]) ) {\n    \t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n    \t\t\t\t\treturn matcher( elem, context, xml );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t} :\n\n    \t\t// Check against all ancestor/preceding elements\n    \t\tfunction( elem, context, xml ) {\n    \t\t\tvar oldCache, uniqueCache, outerCache,\n    \t\t\t\tnewCache = [ dirruns, doneName ];\n\n    \t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n    \t\t\tif ( xml ) {\n    \t\t\t\twhile ( (elem = elem[ dir ]) ) {\n    \t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n    \t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n    \t\t\t\t\t\t\treturn true;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\twhile ( (elem = elem[ dir ]) ) {\n    \t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n    \t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n    \t\t\t\t\t\t// Support: IE <9 only\n    \t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n    \t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n    \t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n    \t\t\t\t\t\t\telem = elem[ dir ] || elem;\n    \t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n    \t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n    \t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n    \t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n    \t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n    \t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n    \t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n    \t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n    \t\t\t\t\t\t\t\treturn true;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn false;\n    \t\t};\n    }\n\n    function elementMatcher( matchers ) {\n    \treturn matchers.length > 1 ?\n    \t\tfunction( elem, context, xml ) {\n    \t\t\tvar i = matchers.length;\n    \t\t\twhile ( i-- ) {\n    \t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n    \t\t\t\t\treturn false;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\treturn true;\n    \t\t} :\n    \t\tmatchers[0];\n    }\n\n    function multipleContexts( selector, contexts, results ) {\n    \tvar i = 0,\n    \t\tlen = contexts.length;\n    \tfor ( ; i < len; i++ ) {\n    \t\tSizzle( selector, contexts[i], results );\n    \t}\n    \treturn results;\n    }\n\n    function condense( unmatched, map, filter, context, xml ) {\n    \tvar elem,\n    \t\tnewUnmatched = [],\n    \t\ti = 0,\n    \t\tlen = unmatched.length,\n    \t\tmapped = map != null;\n\n    \tfor ( ; i < len; i++ ) {\n    \t\tif ( (elem = unmatched[i]) ) {\n    \t\t\tif ( !filter || filter( elem, context, xml ) ) {\n    \t\t\t\tnewUnmatched.push( elem );\n    \t\t\t\tif ( mapped ) {\n    \t\t\t\t\tmap.push( i );\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \treturn newUnmatched;\n    }\n\n    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n    \tif ( postFilter && !postFilter[ expando ] ) {\n    \t\tpostFilter = setMatcher( postFilter );\n    \t}\n    \tif ( postFinder && !postFinder[ expando ] ) {\n    \t\tpostFinder = setMatcher( postFinder, postSelector );\n    \t}\n    \treturn markFunction(function( seed, results, context, xml ) {\n    \t\tvar temp, i, elem,\n    \t\t\tpreMap = [],\n    \t\t\tpostMap = [],\n    \t\t\tpreexisting = results.length,\n\n    \t\t\t// Get initial elements from seed or context\n    \t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n    \t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n    \t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n    \t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n    \t\t\t\telems,\n\n    \t\t\tmatcherOut = matcher ?\n    \t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n    \t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n    \t\t\t\t\t// ...intermediate processing is necessary\n    \t\t\t\t\t[] :\n\n    \t\t\t\t\t// ...otherwise use results directly\n    \t\t\t\t\tresults :\n    \t\t\t\tmatcherIn;\n\n    \t\t// Find primary matches\n    \t\tif ( matcher ) {\n    \t\t\tmatcher( matcherIn, matcherOut, context, xml );\n    \t\t}\n\n    \t\t// Apply postFilter\n    \t\tif ( postFilter ) {\n    \t\t\ttemp = condense( matcherOut, postMap );\n    \t\t\tpostFilter( temp, [], context, xml );\n\n    \t\t\t// Un-match failing elements by moving them back to matcherIn\n    \t\t\ti = temp.length;\n    \t\t\twhile ( i-- ) {\n    \t\t\t\tif ( (elem = temp[i]) ) {\n    \t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\tif ( seed ) {\n    \t\t\tif ( postFinder || preFilter ) {\n    \t\t\t\tif ( postFinder ) {\n    \t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n    \t\t\t\t\ttemp = [];\n    \t\t\t\t\ti = matcherOut.length;\n    \t\t\t\t\twhile ( i-- ) {\n    \t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n    \t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n    \t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n    \t\t\t\t}\n\n    \t\t\t\t// Move matched elements from seed to results to keep them synchronized\n    \t\t\t\ti = matcherOut.length;\n    \t\t\t\twhile ( i-- ) {\n    \t\t\t\t\tif ( (elem = matcherOut[i]) &&\n    \t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n    \t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t// Add elements to results, through postFinder if defined\n    \t\t} else {\n    \t\t\tmatcherOut = condense(\n    \t\t\t\tmatcherOut === results ?\n    \t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n    \t\t\t\t\tmatcherOut\n    \t\t\t);\n    \t\t\tif ( postFinder ) {\n    \t\t\t\tpostFinder( null, results, matcherOut, xml );\n    \t\t\t} else {\n    \t\t\t\tpush.apply( results, matcherOut );\n    \t\t\t}\n    \t\t}\n    \t});\n    }\n\n    function matcherFromTokens( tokens ) {\n    \tvar checkContext, matcher, j,\n    \t\tlen = tokens.length,\n    \t\tleadingRelative = Expr.relative[ tokens[0].type ],\n    \t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n    \t\ti = leadingRelative ? 1 : 0,\n\n    \t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n    \t\tmatchContext = addCombinator( function( elem ) {\n    \t\t\treturn elem === checkContext;\n    \t\t}, implicitRelative, true ),\n    \t\tmatchAnyContext = addCombinator( function( elem ) {\n    \t\t\treturn indexOf( checkContext, elem ) > -1;\n    \t\t}, implicitRelative, true ),\n    \t\tmatchers = [ function( elem, context, xml ) {\n    \t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n    \t\t\t\t(checkContext = context).nodeType ?\n    \t\t\t\t\tmatchContext( elem, context, xml ) :\n    \t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n    \t\t\t// Avoid hanging onto element (issue #299)\n    \t\t\tcheckContext = null;\n    \t\t\treturn ret;\n    \t\t} ];\n\n    \tfor ( ; i < len; i++ ) {\n    \t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n    \t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n    \t\t} else {\n    \t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n    \t\t\t// Return special upon seeing a positional matcher\n    \t\t\tif ( matcher[ expando ] ) {\n    \t\t\t\t// Find the next relative operator (if any) for proper handling\n    \t\t\t\tj = ++i;\n    \t\t\t\tfor ( ; j < len; j++ ) {\n    \t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\treturn setMatcher(\n    \t\t\t\t\ti > 1 && elementMatcher( matchers ),\n    \t\t\t\t\ti > 1 && toSelector(\n    \t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n    \t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n    \t\t\t\t\t).replace( rtrim, \"$1\" ),\n    \t\t\t\t\tmatcher,\n    \t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n    \t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n    \t\t\t\t\tj < len && toSelector( tokens )\n    \t\t\t\t);\n    \t\t\t}\n    \t\t\tmatchers.push( matcher );\n    \t\t}\n    \t}\n\n    \treturn elementMatcher( matchers );\n    }\n\n    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n    \tvar bySet = setMatchers.length > 0,\n    \t\tbyElement = elementMatchers.length > 0,\n    \t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n    \t\t\tvar elem, j, matcher,\n    \t\t\t\tmatchedCount = 0,\n    \t\t\t\ti = \"0\",\n    \t\t\t\tunmatched = seed && [],\n    \t\t\t\tsetMatched = [],\n    \t\t\t\tcontextBackup = outermostContext,\n    \t\t\t\t// We must always have either seed elements or outermost context\n    \t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n    \t\t\t\t// Use integer dirruns iff this is the outermost matcher\n    \t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n    \t\t\t\tlen = elems.length;\n\n    \t\t\tif ( outermost ) {\n    \t\t\t\toutermostContext = context === document || context || outermost;\n    \t\t\t}\n\n    \t\t\t// Add elements passing elementMatchers directly to results\n    \t\t\t// Support: IE<9, Safari\n    \t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n    \t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n    \t\t\t\tif ( byElement && elem ) {\n    \t\t\t\t\tj = 0;\n    \t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n    \t\t\t\t\t\tsetDocument( elem );\n    \t\t\t\t\t\txml = !documentIsHTML;\n    \t\t\t\t\t}\n    \t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n    \t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n    \t\t\t\t\t\t\tresults.push( elem );\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tif ( outermost ) {\n    \t\t\t\t\t\tdirruns = dirrunsUnique;\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\t// Track unmatched elements for set filters\n    \t\t\t\tif ( bySet ) {\n    \t\t\t\t\t// They will have gone through all possible matchers\n    \t\t\t\t\tif ( (elem = !matcher && elem) ) {\n    \t\t\t\t\t\tmatchedCount--;\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// Lengthen the array for every element, matched or not\n    \t\t\t\t\tif ( seed ) {\n    \t\t\t\t\t\tunmatched.push( elem );\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n    \t\t\t// makes the latter nonnegative.\n    \t\t\tmatchedCount += i;\n\n    \t\t\t// Apply set filters to unmatched elements\n    \t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n    \t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n    \t\t\t// no element matchers and no seed.\n    \t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n    \t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n    \t\t\t// numerically zero.\n    \t\t\tif ( bySet && i !== matchedCount ) {\n    \t\t\t\tj = 0;\n    \t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n    \t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n    \t\t\t\t}\n\n    \t\t\t\tif ( seed ) {\n    \t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n    \t\t\t\t\tif ( matchedCount > 0 ) {\n    \t\t\t\t\t\twhile ( i-- ) {\n    \t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n    \t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// Discard index placeholder values to get only actual matches\n    \t\t\t\t\tsetMatched = condense( setMatched );\n    \t\t\t\t}\n\n    \t\t\t\t// Add matches to results\n    \t\t\t\tpush.apply( results, setMatched );\n\n    \t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n    \t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n    \t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n    \t\t\t\t\tSizzle.uniqueSort( results );\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t// Override manipulation of globals by nested matchers\n    \t\t\tif ( outermost ) {\n    \t\t\t\tdirruns = dirrunsUnique;\n    \t\t\t\toutermostContext = contextBackup;\n    \t\t\t}\n\n    \t\t\treturn unmatched;\n    \t\t};\n\n    \treturn bySet ?\n    \t\tmarkFunction( superMatcher ) :\n    \t\tsuperMatcher;\n    }\n\n    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n    \tvar i,\n    \t\tsetMatchers = [],\n    \t\telementMatchers = [],\n    \t\tcached = compilerCache[ selector + \" \" ];\n\n    \tif ( !cached ) {\n    \t\t// Generate a function of recursive functions that can be used to check each element\n    \t\tif ( !match ) {\n    \t\t\tmatch = tokenize( selector );\n    \t\t}\n    \t\ti = match.length;\n    \t\twhile ( i-- ) {\n    \t\t\tcached = matcherFromTokens( match[i] );\n    \t\t\tif ( cached[ expando ] ) {\n    \t\t\t\tsetMatchers.push( cached );\n    \t\t\t} else {\n    \t\t\t\telementMatchers.push( cached );\n    \t\t\t}\n    \t\t}\n\n    \t\t// Cache the compiled function\n    \t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n    \t\t// Save selector and tokenization\n    \t\tcached.selector = selector;\n    \t}\n    \treturn cached;\n    };\n\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n    select = Sizzle.select = function( selector, context, results, seed ) {\n    \tvar i, tokens, token, type, find,\n    \t\tcompiled = typeof selector === \"function\" && selector,\n    \t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n    \tresults = results || [];\n\n    \t// Try to minimize operations if there is only one selector in the list and no seed\n    \t// (the latter of which guarantees us context)\n    \tif ( match.length === 1 ) {\n\n    \t\t// Reduce context if the leading compound selector is an ID\n    \t\ttokens = match[0] = match[0].slice( 0 );\n    \t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n    \t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n    \t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n    \t\t\tif ( !context ) {\n    \t\t\t\treturn results;\n\n    \t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n    \t\t\t} else if ( compiled ) {\n    \t\t\t\tcontext = context.parentNode;\n    \t\t\t}\n\n    \t\t\tselector = selector.slice( tokens.shift().value.length );\n    \t\t}\n\n    \t\t// Fetch a seed set for right-to-left matching\n    \t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n    \t\twhile ( i-- ) {\n    \t\t\ttoken = tokens[i];\n\n    \t\t\t// Abort if we hit a combinator\n    \t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tif ( (find = Expr.find[ type ]) ) {\n    \t\t\t\t// Search, expanding context for leading sibling combinators\n    \t\t\t\tif ( (seed = find(\n    \t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n    \t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n    \t\t\t\t)) ) {\n\n    \t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n    \t\t\t\t\ttokens.splice( i, 1 );\n    \t\t\t\t\tselector = seed.length && toSelector( tokens );\n    \t\t\t\t\tif ( !selector ) {\n    \t\t\t\t\t\tpush.apply( results, seed );\n    \t\t\t\t\t\treturn results;\n    \t\t\t\t\t}\n\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \t// Compile and execute a filtering function if one is not provided\n    \t// Provide `match` to avoid retokenization if we modified the selector above\n    \t( compiled || compile( selector, match ) )(\n    \t\tseed,\n    \t\tcontext,\n    \t\t!documentIsHTML,\n    \t\tresults,\n    \t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n    \t);\n    \treturn results;\n    };\n\n    // One-time assignments\n\n    // Sort stability\n    support.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n    // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n    support.detectDuplicates = !!hasDuplicate;\n\n    // Initialize against the default document\n    setDocument();\n\n    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n    support.sortDetached = assert(function( el ) {\n    \t// Should return 1, but returns 4 (following)\n    \treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n    });\n\n    // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n    if ( !assert(function( el ) {\n    \tel.innerHTML = \"<a href='#'></a>\";\n    \treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n    }) ) {\n    \taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n    \t\tif ( !isXML ) {\n    \t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n    \t\t}\n    \t});\n    }\n\n    // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n    if ( !support.attributes || !assert(function( el ) {\n    \tel.innerHTML = \"<input/>\";\n    \tel.firstChild.setAttribute( \"value\", \"\" );\n    \treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n    }) ) {\n    \taddHandle( \"value\", function( elem, name, isXML ) {\n    \t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n    \t\t\treturn elem.defaultValue;\n    \t\t}\n    \t});\n    }\n\n    // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n    if ( !assert(function( el ) {\n    \treturn el.getAttribute(\"disabled\") == null;\n    }) ) {\n    \taddHandle( booleans, function( elem, name, isXML ) {\n    \t\tvar val;\n    \t\tif ( !isXML ) {\n    \t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n    \t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n    \t\t\t\t\tval.value :\n    \t\t\t\tnull;\n    \t\t}\n    \t});\n    }\n\n    // EXPOSE\n    var _sizzle = window.Sizzle;\n\n    Sizzle.noConflict = function() {\n    \tif ( window.Sizzle === Sizzle ) {\n    \t\twindow.Sizzle = _sizzle;\n    \t}\n\n    \treturn Sizzle;\n    };\n\n    if ( typeof define === \"function\" && define.amd ) {\n    \tdefine(function() { return Sizzle; });\n    // Sizzle requires that there be a global window in Common-JS like environments\n    } else if ( typeof module !== \"undefined\" && module.exports ) {\n    \tmodule.exports = Sizzle;\n    } else {\n    \twindow.Sizzle = Sizzle;\n    }\n    // EXPOSE\n\n    })( window );\n\n    if(typeof Object.assign !== 'function') {\n        Object.assign = function (target, ...args) {\n            if(!target) {\n                throw new TypeError('Cannot convert undefined or null to object')\n            }\n            let result = Object(target);\n            for(let i = 0; i < args.length;i++) {\n                let item = args[i];\n                if(item) {\n                    for(let key in item) {\n                        if(Object.prototype.hasOwnProperty.call(item, key)) {\n                            result[key] = item[key];\n                        }\n                    }\n                }\n            }\n            return result;\n        };\n    }\n\n    // IE 中兼容 Element.prototype.matches\n    if (!Element.prototype.matches) {\n        Element.prototype.matches =\n            Element.prototype.matchesSelector ||\n            Element.prototype.mozMatchesSelector ||\n            Element.prototype.msMatchesSelector ||\n            Element.prototype.oMatchesSelector ||\n            Element.prototype.webkitMatchesSelector ||\n            function(s) {\n                var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n                    i = matches.length;\n                while (--i >= 0 && matches.item(i) !== this) {}\n                return i > -1;\n            };\n    }\n\n    var index = new Editor();\n\n    return index;\n\n}));\n"]}